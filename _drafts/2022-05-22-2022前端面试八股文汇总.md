---
layout: post
title: 2022前端面试八股文汇总
author: Max
categories: 大前端
tags: 面试
---

互联网寒冬，面试八股牢记于心。话虽如此，巩固并吃透一个知识点才是正道。
技术飞速迭代的今天，当你学不动的时候，停下脚步歇歇，回头看看也未尝不可。
作为一个正在接受社会毒打的前端工程师，以下是个人收集并归纳总结的一些面试常见问题，
问题的相关细节会放在括号中，方便拓展和举一反三。

## JavaScript 核心

### 经典概念

#### javascript 有哪些原始类型

Undefined，Null，Boolean，Number，String，Symbol，Bigint
（一项新的提案让这个答案可能增加 Record 和 Tuple 这两个不可变数据类型）

#### 执行上下文和作用域链

变量或者函数的执行上下文决定了他们可以访问那些数据，每个函数都有自己的执行上下文，当函数被执行的时候，
它的上下文会被推入 **_执行栈_**，并创建一个作用域链，执行时沿着作用域链查找变量，
函数执行完毕后，执行上下文也会被弹出。

#### 闭包

闭包是指那些引用了另一个函数作用域中的变量的函数，通常在嵌套函数中实现。内部的函数作为参数传递或结果返回，
仍能访问到其所在的外部函数的变量。闭包形成的原因是当一个函数执行完毕时，将会销毁其执行上下文以及附带的活
动对象， 但由于外部函数的活动对象已被添加到内部函数的作用域链中，故无法被销毁，仍然保留在内存中，供内部函
数使用。 闭包的使用场景包括防抖、节流、单次调用函数等。

#### 尾调用优化

尾调用优化是 ES6 规范新增的内存管理优化机制（严格模式下开启），当一个函数的返回值是是它内部返回值的时候，
通过重用执行栈栈帧的 方式优化内存管理（内部函数执行上下文执行完毕后不会直接弹出，而是先判断它的外部栈帧
是否有存在必要）。

#### 构造函数

任何函数只要通过`new`操作符调用就是构造函数（一个函数也可以通过`new.target`来判断自己是否最为构造函数
被调用）。当使用`new`操作符执行构造函数时，js 解释器会在内存中新建一个对象，并将该对象的`__proto__`属性
赋值为构造函数的原型对象`prototype`，然后构造函数内部的`this`被赋值为这个新对象，执行完内部代码后返回
这个对象（如果构造函数直接返回了一个对象，除非手动操作否则原型链会断掉）。

#### 原型和原型链

每个函数（包括 ES6 类）都会创建一个`prototype`属性指向它的原型对象，原型对象的`constructor`属性也会
指向这个函数（或类），当这个函数作为构造函数使用，实例化出一个对象时，这个实例对象的`__proto__`属性也会
指向构它的原型对象。当一个函数的原型对象是另一个构造函数的实例时，就会形成原型链。

### 为什么 0.1+0.2 不等用 0.3

任何使用了 IEEE754 浮点规范的语言都会存在这个问题，双精度浮点数的可靠位为 15 位，16 位之后的可能是对不上的。
0.1 和 0.2 储存值都比实际值要大一些，所以结果不等于 0.3，比较小数是否相当，应该使用两者的差值与 ES6 新增的
`Number.EPSILON`属性比较：

```javascript
if (0.1 + 0.2 - 0.3 < Number.EPSILON) {
  console.log(`0.1+0.2=0.3`);
}
```

### javascript 如何实现继承

原型链、借用构造函数、组合继承、原型式继承、寄生式继承、寄生式组合继承。[详见这里](https://blog.streakingman.com/javascript/2022/04/02/javascript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF.html)

### 奇技淫巧

#### 自己实现`call`或者`apply`

```javascript
Function.prototype.myApplay = function (newThis, argArray) {
  const tempObj = newThis ?? window;
  const funcSymb = Symbol("tempFunc");
  // 当一个函数作为对象的属性调用时，函数内this指向这个对象
  // 利用这点来达到绑定传入的newThis的目的
  tempObj[funcSymb] = this;
  tempObj[funcSymb](...argArray);
};
```

#### 自己实现`bind`

```javascript
Function.prototype.myBind = function (newThis) {
  const self = this;
  // 利用闭包，绑定this
  return function () {
    self.apply(newthis, arguments);
  };
};
```

## 浏览器与 javaScript

### HTTP、HTTPS 和 HTTP2

- HTTPS = HTTP + SSL/TLS，（TLS 是 SSL 标准化后的产物）
- SSL 使用非对称加密，对称指的是加密解密使用同一密钥，非对称使用不同密钥
- HTTPS 证书中包含了公钥，发送数据时会使用该公钥加密，接受端使用私钥解密，加大了破解成本，提高安全性
- HTTPS 加密和解密过程会有一定程度的性能损耗
- 目前广泛使用的时 HTTP 协议版本为 1.1
- HTTP2 建立在 HTTPS 协议的基础上，安全
- HTTP2 通过二进制分帧来进行数据传输，高效
- HTTP2 一个域建立一次 TCP 链接，使用多路复用和连接共享，没有 HTTP1 中同个域的并发限制
  （得益于分帧机制，帧可以乱序发送，不再依赖多个 TCP 实现并行）

### HTTP 缓存机制

浏览器每次发起请求，都会现在浏览器缓存中查找该请求的结果以及缓存标识，且每次拿到结果，都会将该结果
和缓存标识存入浏览器缓存中，而这个缓存过程又分为强制缓存和协商缓存。服务端控制缓存规则的字段包括
`Expires`（HTTP1.0 的字段，客户端对比时间存在缺陷，已被后者取代）和`Cache-Control`（优先级更高），
`Cache-Control`的取值有：

- public 所有内容都被缓存
- private 默认值，所有内容只有客户端可以缓存
- no-cache 客户端缓存内容，但是否使用缓存要经过协商缓存验证
- no-store 所有内容都不会被缓存
- max-age=time 缓存内容在 time 秒后失效

当发送请求时，不存在缓存结果或上述标志，则直接向服务器发起请求，如果有这是缓存标志，且存在缓存结果，
则直接返回缓存结果（强制缓存生效，取缓存先内存后硬盘），如果缓存结果失效，则携带缓存标志向服务器请求，
服务器可能会返回 304（协商缓存生效）， 浏览器直接使用缓存，也可能返回 200（协商了决定给新的），
浏览器使用新的结果。

协商缓存的过程中，请求会携带一些信息帮助浏览器判断：

- last-modified-since 上一次请求的返回体中的 last-modified 值
- if-none-match 上一次请求的返回体中的 etag 标识

### 跨域

协议、域名、端口任一不同即为跨域，浏览器的同源策略，不限制跨域请求的发送，但会拦截请求响应，
常用的跨域解决办法：

- CORS，服务端设置跨域原资源共享
- JSONP，浏览器告诉服务一个返回函数的名称，服务在返回的 scipt 里调用这个回调函数，同时传进客户端需要的数据，
  这样返回的代码就能在浏览器上执行了
- 子域名跨父域名时，通过更改`document.domain`为父域名即可
- 嵌套 iframe 跨父窗口，父域无法访问不同源的 iframe 内容，但 iframe 可以向上调用`window.parent`，
  两者间也可以通过`postMessage`API 来通信

### cookie

默认情况下跨域 ajax 请求不会携带`cookie`，除非设置`withCredentials`属性为`true`

返回报文的`Set-Cookie`可以设置浏览器`cookie`：

- name=value 普通键值对
- Domain 指定 cookie 有效的域名，发送到这个域名的请求都会携带 cookie，可以指定是否包含子域名
- Path 指定使用 cookie 的路径，请求 URL 包含这个路径才会携带 cookie
- Expires 过期时间，即什么时间之后就不要携带 cookie 了
- Secure 安全标志，设置之后只有使用了 SSL 安全连接的情况才会携带 cookie
- SameSite 可设置三个值
  - Strict 完全禁止第三方 cookie
  - Lax 默认值，仅发送连接、预加载还有 GET 请求的 cookie
  - None 关闭该设置

### 事件循环

JavaScript 设计之初就是一门处理浏览器网页交互的脚本语言，这决定了它注定是一门单线程语言
(多个线程同时操作 ui 是很麻烦的事情)。浏览器式多线程的，当 js 主线程调用`setTimeout`和
`addEventLisenter`之类的方法时，会触发其他线程（定时器触发线程、事件触发线程），以此来实现
异步非阻塞。其他线程执行完毕后会将对应的额回调函数较为任务队列维护，当 js 主线程执行栈为空时，
从这个队列中依次去除任务（回调函数）执行。新一轮的执行若有异步任务则重复以上步骤，这个过程称之为
事件循环。

### 宏任务与微任务

- 宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame、
  requestIdleCallback（浏览器空闲时段调用）、ajax
- 微任务：process.nextTick（node 中）、promise、MutationObserver、MessageChannel

### 首屏性能优化

- 尽量减少请求次数
- gzip 压缩静态资源
- dns 预连接`<link rel="dns-prefetch" href="url">`
- cdn 加速资源
- 优化缓存机制（更新频率低的可以加大缓存时间）
- 使用 http2
- 图片懒加载
- 优化 dom 结构，减少无用节点，避免页面重绘
- 提高首屏加载代码的覆盖率，想办法剔除为使用的代码

### 浏览器渲染过程
- HTML->DOM树，CSS->CSSOM规则树
- DOM树+CSSOM规则树=渲染树
- 遍历渲染树，先开始布局
- 绘制节点

### 浏览器资源加载过程

## 框架

### 什么是 MVVM

### Vue2

#### 解释下数据驱动、双向绑定

#### Vue 的实例化过程

#### Vue 的挂载过程，

#### 讲一讲 vue2 的响应式原理

#### vue 是怎么实现组件化的

#### vue-router 原理

#### vuex 原理

### Vue3

### React

## 打包&构建

### webpack

### esbuild

### rollup

### vite
