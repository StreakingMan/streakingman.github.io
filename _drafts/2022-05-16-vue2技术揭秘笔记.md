---
layout: post
title: vue2技术揭秘笔记
author: Max
categories: 大前端
tags: 前端框架 vue2
---

本文是[vue技术揭秘](https://ustbhuangyi.github.io/vue-analysis/v2/prepare/)的笔记，
除非特使，vue都是指的2.x版本。
跟着大佬的脚步过了一边vue2底层，分析得很详细，站在巨人的肩膀上果然能够看的更高，有时间精力能力的时候必定自己读一番源码。

揭秘主要分为了数据驱动、组件化、响应式原理、编译拓展这几个部分，也分析了vue生态vue router和vuex。

## 前置准备

在最开头，介绍了vue的整体情况，vue2是使用FlowJS做的静态类型检查，没有使用过这个库，但看介绍跟TS挺像的。
vue的源码分为以下部分
```
src
├── compiler        # 编译相关 
├── core            # 核心代码 
├── platforms       # 不同平台的支持(web和weex)
├── server          # 服务端渲染
├── sfc             # .vue 文件解析
├── shared          # 共享代码(指浏览器端和服务端的通用代码)
```

> [Weex](https://doc.weex.io/zh/)简单说就是一个用web技术开发原生应用的框架

vue源码是基于Rollup构建的，从构建脚本可以看出产物有3种
```json
{
  "script": {
    "build": "node scripts/build.js",
    "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",
    "build:weex": "npm run build -- weex"
  }
}
```

> 关于node环境下的`process.argv`参数，数组前两个为node和执行文件的路径，第三个开始依次为命令中空格相间的自负
> 所以`web-runtime-cjs,web-server-renderer`和`weex`这些参数是通过`process.argv[2]`获取的

`scripts/build.js`的构建过程简单来说就是：判断命令参数->过滤相应的预设构建配置->构建不同用途的vue.js，
详细的构建过程这里不再继续展开，构建配置简单来说就是以下内容的组合：
- 模块系统，cjs还是esm
- 环境，如开发模式的包会包含各种日志打印，生成模式则shake掉了相关代码
- 运行时和编译器
- web还是weex
- 浏览器和服务端
- webpack插件

vue同时还有运行时、运行时+编译器的版本，这两者的区别简单理解就是`render`函数是在什么时候生成的。

> vue的最终渲染都是`render`函数，该函数返回的是虚拟dom，编译指的是`template`转换成`render`函数的过程

如果是在代码运行的时候去做编译这一过程，那么需要用的是运行时+编译器的版本，
如果在代码运行前就做好了编译工作，则只需要纯运行时版本（`vue-loader`就是用来体检做编译工作的）

观察运行时+编译器的产物`src/platforms/web/entry-runtime-with-compiler.js`，作为入口文件，做的事情十分简洁明了：
1. 引入运行时Vue还有编译器，以及其他的依赖
2. 重写运行时Vue原型上的$mount方法，主要是做了些前置工作：
   1. 检查挂载的根元素，不能是`html`或者`body`
   2. 检查渲染函数，没有渲染函数时检查`template`并转换为渲染函数，没有`template`则取挂载元素的`outerHTML`作为`template`
   3. 继续调用原本的$mount
3. 将编译器挂载到拓展后的Vue的`compile`属性
4. 导出拓展的Vue

接下来继续看vue运行时`src/platforms/web/runtime/index.js`



