---
layout: post
title: vue2技术揭秘笔记
author: Max
categories: 大前端
tags: 前端框架 vue2
---

本文是[vue 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/v2/prepare/)的笔记
（以下统一《揭秘》指代）， 除非特使，vue 都是指的 2.x 版本。
跟着大佬的脚步过了一边 vue2 底层，分析得很详细，站在巨人的肩膀上果然能够看的更高，有时间精力能力的时候必定自己读一番源码。

揭秘主要分为了数据驱动、组件化、响应式原理、编译拓展这几个部分，也分析了 vue 生态 vue router 和 vuex。

## 前置准备

《揭秘》最开头，介绍了 vue 的整体情况，vue2 是使用 FlowJS 做的静态类型检查，没有使用过这个库，但看介绍跟 TS 挺像的。
vue 的源码分为以下部分

```
src
├── compiler        # 编译相关
├── core            # 核心代码
├── platforms       # 不同平台的支持(web和weex)
├── server          # 服务端渲染
├── sfc             # .vue 文件解析
├── shared          # 共享代码(指浏览器端和服务端的通用代码)
```

> [Weex](https://doc.weex.io/zh/)简单说就是一个用 web 技术开发原生应用的框架

vue 源码是基于 Rollup 构建的，从构建脚本可以看出产物有 3 种

```json
{
  "script": {
    "build": "node scripts/build.js",
    "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",
    "build:weex": "npm run build -- weex"
  }
}
```

> 关于 node 环境下的`process.argv`参数，数组前两个为 node 和执行文件的路径，第三个开始依次为命令中空格相间的字符
> 所以`web-runtime-cjs,web-server-renderer`和`weex`这些参数是通过`process.argv[2]`获取的

`scripts/build.js`的构建过程简单来说就是：判断命令参数->过滤相应的预设构建配置->构建不同用途的 vue.js，
详细的构建过程这里不再继续展开，构建配置简单来说就是以下内容的组合：

- 模块系统，cjs 还是 esm
- 环境，如开发模式的包会包含各种日志打印，生成模式则 shake 掉了相关代码
- 运行时和编译器
- web 还是 weex
- 浏览器和服务端
- webpack 插件

vue 同时还有运行时、运行时+编译器的版本，这两者的区别简单理解就是`render`函数是在什么时候生成的。

> vue 的最终渲染都是`render`函数，该函数返回的是虚拟 dom，编译指的是`template`转换成`render`函数的过程

如果是在代码运行的时候去做编译这一过程，那么需要用的是运行时+编译器的版本，
如果在代码运行前就做好了编译工作，则只需要纯运行时版本（`vue-loader`就是用来体检做编译工作的）

观察运行时+编译器的产物`src/platforms/web/entry-runtime-with-compiler.js`，作为入口文件，做的事情十分简洁明了：

1. 引入运行时 Vue 还有编译器，以及其他的依赖
2. 重写运行时 Vue 原型上的$mount 方法，主要是做了些前置工作：
   1. 检查挂载的根元素，不能是`html`或者`body`
   2. 检查渲染函数，没有渲染函数时检查`template`并转换为渲染函数，没有`template`则取挂载元素的`outerHTML`作为`template`
   3. 继续调用原本的$mount
3. 将编译器挂载到拓展后的 Vue 的`compile`属性
4. 导出拓展的 Vue

接下来继续看 vue 运行时`src/platforms/web/runtime/index.js`，主要做了以下工作：

1. 从`./instance/index`引入`Vue`对象，引入`initGlobalAPI`和其他工具
2. 调用`initGlobalAPI`初始化全局 Vue API
3. 拓展`Vue.prototype`，定义了`$isServer`和`$ssrContext`
4. 拓展`Vue`，定义了`FunctionalRenderContext`
5. 标记版本并导出`Vue`

进到`src/core/instance/index.js`，可以看到`Vue`是一个函数类，需要用`new`来实例化
（并且内部做了判断，`Vue`只能作为构造方法使用），在这个类导出之前，有一系列的`xxxMixin`方法对这个类的原型进行一系列的拓展

```javascript
function Vue(options) {
  if (process.env.NODE_ENV !== "production" && !(this instanceof Vue)) {
    warn("Vue is a constructor and should be called with the `new` keyword");
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
```

说会`initGlobalAPI`，则是`Vue.prototype`进行了一系列的方法拓展后，对`Vue`对象本身拓展全局静态方法，
现在挂载了以下属性到`Vue`上：

- util
- set
- delete
- nextTick
- options

然后是下列的初始化操作：

```javascript
initUse(Vue);
initMixin(Vue);
initExtend(Vue);
initAssetRegisters(Vue);
```

> 这里需要注意下流程中对原型的拓展和对原对象的静态拓展，在原型上拓展的内容，是 vue 实例可以访问到的，
> 而在`Vue`上拓展的静态全局 API，则需要通过`Vue`对下岗来访问

大致过完了框架的大流程，接下来就是核心的分析了

## 数据驱动

数据驱动作为 vue 的核心已经老八股文了，面试经常会问，而我也是经常那几句话：

- 数据劫持，`defineProperty`
- 依赖收集，发布订阅
- 啊吧啊吧...

哈哈，光知道这些肯定不够的，知其然知其所以然，《揭秘》首先带我们继续深扒 vue 的实例化过程，
回到`Vue`构造函数，可以看到在判断完是否作为构造方法调用后，紧接着调用了`this.init`，
而这个初始化方法正是`initMixin`在`Vue.prototype`上拓展的，主要做了以下工作：

- 合并配置项
- 初始化生命周期（给vm实例加上各种生命周期的标记）
- 初始化事件中心（根据parent更新自己的listener）
- 初始化渲染
- 初始化 data、props、computed、watcher 等

代码中可以清晰的看到`beaforeCreate`和`created`的两钩子前后发生了什么：
```javascript
//...
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
//...
```

相关的细节并没有继续深入，接下来是`vm`的挂载过程，上文也提到运行时+编辑器版本的入口，
对`Vue.prototype`上的`$mount`进行了拓展，`$mount`在查询到元素后，最终调用了`lifecycle`的`mountComponent`方法，

