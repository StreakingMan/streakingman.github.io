---
layout: post
title: Vue.js设计与实现笔记
author: Max
categories: 大前端
tags: vue3
---

本文为霍春阳《Vue.js 设计与实现》读书笔记，本书全方位的分析了 vue3（当然也包括一些 vue2 的对比），
从框架到细节都有涉猎，不管是用来自我提升或是准备面试，都是一本很棒的书。同时也建议先看尤大的 vue3
源码讲解相关视频建立一个整体概念后，再看这本书会有更好的效果。

## 框架设计

vue 是一个声明式的框架（声明式描述结果，命令是描述过程），它包含运行时和编译时。

框架的产物应该考虑不同需求：

- 生产包去除开发日志打印
- 针对不同的引入方式，产出不同格式（`esm-browser`，`esm-bundler`，`IIFE`...)
- 暴露特性开关来进一步 Tree-shaking

vue 框架的核心包括虚拟 DOM、渲染器和编译器。组件的本质是一组虚拟 DOM 的封装，vue 模板最终会被编译器
转换为渲染函数。

## 响应系统

vue3 的响应式除了将`Object.defineProperty`换为了`Proxy`，为了暴露出独立的响应式 API，内部的
实现也有不少区别。

vue3 新增了注册副作用函数的能力，副作用函数一个比较有意思的点，在依赖收集的过程中，怎么把依赖所在
的函数环境储存下来以供发布更新时 触发呢？这里其实会通过一个全局的变量来临时记录当前的执行函数，当
执行流不断游走，会不多重复这个过
程：进入副作用函数->记录当前函数->执行函数触发响应式对象访问器->访问器收集当前函数到订阅者->
离开->下一个副作用函数...

```javascript
let activeEffect;

function effect(fn) {
  activeEffect = fn;
  // fn执行时会触发响应式对象的访问器，收集activeEffect
  fn();
}
```

响应系统的依赖关系是在一个全局对象中维护的。副作用函数与被操作的目标对象是通过`target`和`key`来
建立联系的，该联系使用了`WeakMap`维护， 它用`target`对象作为`key`，`value`则是由
`[target.keyName]: Set(...EffectFns)`组成的`Map`。使用`WeakMap`可以让`target`对象没有被
持有引用时，被垃圾回收器自动收集。

当副作用函数中存在不同分支时，可能会出现重复触发的问题：

```javascript
effect(() => {
  // 假设obj是一个响应式对象，当obj.ok='false'时，
  // 我们的期望时obj.text的改变不再触发这个副作用函数
  document.body.innerText = obj.ok ? obj.text : "not";
});
```

为了解决这个问题，每次`trigger`执行完副作用函数后，都要把这个函数的依赖关系清除，使得下一次`trace`自动
获得最新的依赖关系（比如将`obj.ok`设置为`false`后，下一次的执行流已经切换了分支，不会触发`obj.text`的
访问器，因此不会收集副作用函数到`obj.text`上的订阅），`effect`会重新包装一个`effectFn`并设置它的一个
`deps`缓存数组，`track`方法会记录哪些依赖是用到这个副作用函数的。

为了解决嵌套的副作用函数场景，通过一个栈来存储入栈的执行函数（模拟执行栈），`activeEffect`始终指向栈顶的函数。

为了解决`track`和`trigger`的死循环问题，在`trigger`中加入前置判断：如果其触发的执行函数与当前的标记函数一致，
则不触发执行。

在一次的执行流过程中，我们通常只关注最终的状态，而不需要一些过渡状态，可以通过维护一个单次执行流有效的标记来控制。
这项工作是内部的调度器和任务队列完成的，通过一个 promise 微任务队列来过滤掉中间状态。

## 渲染器

## 组件化

## 编译器

## 服务端渲染
